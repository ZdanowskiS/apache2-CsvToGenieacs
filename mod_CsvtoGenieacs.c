/* 
**  mod_CsvtoGenieacs.c -- Apache sample CsvtoGenieacs module
**  [Autogenerated via ``apxs -n CsvtoGenieacs -g'']
**
**  To play with this sample module first compile it into a
**  DSO file and install it into Apache's modules directory 
**  by running:
**
**    $ apxs -c -i mod_CsvtoGenieacs.c
**
**  Then activate it in Apache's apache2.conf file for instance
**  for the URL /CsvtoGenieacs in as follows:
**
**    #   apache2.conf
**    LoadModule CsvtoGenieacs_module modules/mod_CsvtoGenieacs.so
**    <Location /CsvtoGenieacs>
**    SetHandler CsvtoGenieacs
**    </Location>
**
**  Then after restarting Apache via
**
**    $ apachectl restart
**
**  you immediately can request the URL /CsvtoGenieacs and watch for the
**  output of this module. This can be achieved for instance via:
**
**    $ lynx -mime_header http://localhost/CsvtoGenieacs 
**
**  The output should be similar to the following one:
**
**    HTTP/1.1 200 OK
**    Date: Tue, 31 Mar 1998 14:42:22 GMT
**    Server: Apache/1.3.4 (Unix)
**    Connection: close
**    Content-Type: text/html
**  
**    The sample page from mod_CsvtoGenieacs.c
*/ 
/*
Parts of code can be found at
https://httpd.apache.org/docs/2.4/developer/modguide.html
*/
#include "httpd.h"
#include "http_config.h"
#include "http_protocol.h"
#include "ap_config.h"

#include <json-c/json.h>

#include <stdio.h>
#include <stdlib.h>

///////////////////////////////////////////////////////////////////////
typedef struct {
    const char *path;        
    const char *token; 
} struct_config;

static struct_config config;


const char *set_path(cmd_parms *cmd, void *cfg, const char *arg)
{
    config.path = arg;
    return NULL;
}

const char *set_token(cmd_parms *cmd, void *cfg, const char *arg)
{
    config.token = arg;
    return NULL;
}

static const command_rec get_config[] =
{
    AP_INIT_TAKE1("Token", set_token, NULL, RSRC_CONF, "Set required token"),
    AP_INIT_TAKE1("Path", set_path, NULL, RSRC_CONF, "The path to configuration"),
    { NULL }
};
/* The sample content handler */
static int CsvtoGenieacs_handler(request_rec *r)
{
    if (strcmp(r->handler, "csvtogenieacs")) {
        return DECLINED;
    }
    r->content_type = "text/html"; 
/* Check token */
    const char *password;
    password = apr_table_get(r->headers_in, "AUTHORIZATION");

    if((password!=NULL && strcmp(password, config.token)!=0) || password==NULL)
    {
        ap_rputs("401 Unauthorized", r);

        return OK;
    }

///////////////// 
    const char *serial=NULL;
    const char *deviceid=NULL;
    const char *const fileext=".csv";

    char buffer[100];
    struct json_object *jobj;

/* how to read php://input in C */
    int ret_code = ap_setup_client_block(r, REQUEST_CHUNKED_ERROR);

    if (ret_code == OK) {
        if (ap_should_client_block(r)) {
            int dataBytesRead = ap_get_client_block(r, buffer, 100);
            /* example copy data*/
            //char *json[dataBytesRead];
            //memcpy(json, buffer, dataBytesRead);

            jobj = json_tokener_parse(buffer);
            char *jsonarray= (char *)json_object_get_array(jobj);

            /* check what we get in body and take what we need */
            json_object_object_foreach(jobj, key, val) {
                if(strcmp(key,"serial")==0)
                {
                    serial=(char *) json_object_get_string(val);
                }
                if(strcmp(key,"cpeid")==0)
                {
                    deviceid=(char *) json_object_get_string(val);
                }
            }
        }
    }

///////////
    /* if we didn't get serial in body let's try from GET*/
    if(serial==NULL)
    {
        apr_table_t*GET;
        ap_args_to_table(r, &GET);
        serial = apr_table_get(GET, "serial");
    }
    /*checking strlen on null is bad idea */
    if(!serial)
    {
        serial="";
    }
    size_t s1len = strlen (config.path);
    size_t s2len = strlen (serial);
    size_t s3len = strlen (fileext);

    size_t sumlen=s1len+s2len+s3len+1;

    char filename[sumlen];

    FILE * fp;
    char * line = NULL;
    size_t len = 0;
    ssize_t read;
/*
 create filename to read, using strcat risks overflow and overwriting other varibles
*/
   // strcat(filename, serial);
   // strcat(filename, ".csv");
    snprintf (filename, sumlen, "%s%s%s", config.path, serial, fileext);

/* open file based on serial/deviceid*/
    fp = fopen(filename, "r");
    if (fp == NULL)
    {
        if(deviceid)
        {
            size_t s2len = strlen (deviceid);
            snprintf (filename, s1len+s2len+s3len+1, "%s%s%s", config.path, deviceid, fileext);
            fp = fopen(filename, "r");
        }
        if (fp == NULL)
        {
            ap_rputs("No configuration found", r);
            return OK;
           // exit(EXIT_FAILURE);
        }
    }

    struct json_object *obj1, *res, *sub_obj1;

    obj1 = json_object_new_object();

    const char *a[5];
    int i=0;
    a[0]="name";
    a[1]="taskname";
    a[2]="type";
    a[3]="param";
    a[4]="value";

    res = json_object_new_array();

    while ((read = getline(&line, &len, fp)) != -1) {
        i=0;
        char *task = strtok(line, ";");
        while (task != NULL)
        {
            task[strcspn(task, "\n")] = 0;
            json_object_object_add(obj1, a[i], json_object_new_string(task));
            task = strtok(NULL, ";");
            i+=1;
        }
        json_object_array_add(res, json_object_get(obj1));
    }
    fclose(fp);
/* return file content in form of json */
    ap_rprintf(r, "%s", json_object_to_json_string(res));

    return OK;
}

/* struct for geting POST data from apache documentation */
typedef struct {
    const char *key;
    const char *value;
} keyValuePair;

keyValuePair *readPost(request_rec *r) {
    apr_array_header_t *pairs = NULL;
    apr_off_t len;
    apr_size_t size;
    int res;
    int i = 0;
    char *buffer;
    keyValuePair *kvp;

    res = ap_parse_form_data(r, NULL, &pairs, -1, HUGE_STRING_LEN);
    if (res != OK || !pairs) return NULL;
    kvp = apr_pcalloc(r->pool, sizeof(keyValuePair) * (pairs->nelts + 1));
    while (pairs && !apr_is_empty_array(pairs)) {
        ap_form_pair_t *pair = (ap_form_pair_t *) apr_array_pop(pairs);
        apr_brigade_length(pair->value, 1, &len);
        size = (apr_size_t) len;
        buffer = apr_palloc(r->pool, size + 1);
        apr_brigade_flatten(pair->value, buffer, &size);
        buffer[len] = 0;
        kvp[i].key = pair->name;
        kvp[i].value = buffer;

        i++;
    }
    return kvp;
}

static int CsvtoGenieacs_file(request_rec *r)
{
    if (strcmp(r->handler, "csvtogenieacsfile")) {
        return DECLINED;
    }

    char *cpename=NULL;
    char *body;
    char *filename;
    filename=config.path;
    FILE * fp;

    /*~~~~~~~~~~~~~~~~~~~~~~*/
    keyValuePair *formData;
    /*~~~~~~~~~~~~~~~~~~~~~~*/

    r->content_type = "text/html";  

/* read POST */
    formData = readPost(r);
    if (formData) {
        int i;
        for (i = 0; &formData[i]; i++) {
            if (formData[i].key && formData[i].value) {
                if(strcmp(formData[i].key,"serial")==0){
                    cpename=formData[i].value;
                    strcat(filename, formData[i].value);
                }
                if(strcmp(formData[i].key,"body")==0){
                    body=formData[i].value;
                }
            } else {
                break;
            }
        }
    }
    if(cpename)
    {
        strcat(filename, ".csv");
        fp = fopen (filename, "w");
        fprintf(fp, "%s", body);
        fclose(fp);
    }

    ap_rputs("<h2>Create new configuration file</h2>", r);

    ap_rputs("<form action='' method='post' ><span>Serial/Device ID:<input type='text' id='serial' name='serial'></span><BR>", r);
    ap_rputs("<span>Body<textarea  name='body' rows='4' cols='90'></textarea></span><BR>", r);

    ap_rputs("<input type='submit'></form>", r);

    return OK;
}

static void CsvtoGenieacs_register_hooks(apr_pool_t *p)
{
    config.path = "/tmp";
    config.token = "abcd1";
    ap_hook_handler(CsvtoGenieacs_handler, NULL, NULL, APR_HOOK_MIDDLE);
    ap_hook_handler(CsvtoGenieacs_file, NULL, NULL, APR_HOOK_MIDDLE);
}

/* Dispatch list for API hooks */
module AP_MODULE_DECLARE_DATA CsvtoGenieacs_module = {
    STANDARD20_MODULE_STUFF, 
    NULL,                  /* create per-dir    config structures */
    NULL,                  /* merge  per-dir    config structures */
    NULL,                  /* create per-server config structures */
    NULL,                  /* merge  per-server config structures */
    get_config,                  /* table of config file commands       */
    CsvtoGenieacs_register_hooks  /* register hooks                      */
};

